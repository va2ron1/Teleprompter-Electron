"use strict";

const codeSign_1 = require("./codeSign");
const bluebird_1 = require("bluebird");
const platformPackager_1 = require("./platformPackager");
const metadata_1 = require("./metadata");
const path = require("path");
const util_1 = require("./util");
const fs_extra_p_1 = require("fs-extra-p");
const signcode_tf_1 = require("signcode-tf");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./awaiter");
class WinPackager extends platformPackager_1.PlatformPackager {
    constructor(info, cleanupTasks) {
        super(info);
        if (this.options.cscLink != null && this.options.cscKeyPassword != null) {
            this.certFilePromise = codeSign_1.downloadCertificate(this.options.cscLink).then(path => {
                cleanupTasks.push(() => fs_extra_p_1.deleteFile(path, true));
                return path;
            });
        } else {
            this.certFilePromise = bluebird_1.Promise.resolve(null);
        }
        this.iconPath = this.getValidIconPath();
        if (this.options.dist && (this.customBuildOptions == null || this.customBuildOptions.loadingGif == null)) {
            const installSpinnerPath = path.join(this.buildResourcesDir, "install-spinner.gif");
            this.loadingGifStat = util_1.statOrNull(installSpinnerPath).then(it => it != null && !it.isDirectory() ? installSpinnerPath : null);
        }
    }
    get platform() {
        return metadata_1.Platform.WINDOWS;
    }
    getValidIconPath() {
        return __awaiter(this, void 0, void 0, function* () {
            const iconPath = path.join(this.buildResourcesDir, "icon.ico");
            yield checkIcon(iconPath);
            return iconPath;
        });
    }
    pack(outDir, arch, postAsyncTasks) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            // we must check icon before pack because electron-packager uses icon and it leads to cryptic error message "spawn wine ENOENT"
            yield this.iconPath;
            if (!this.options.dist) {
                return yield _super("pack").call(this, outDir, arch, postAsyncTasks);
            }
            const appOutDir = this.computeAppOutDir(outDir, arch);
            const installerOut = computeDistOut(outDir, arch);
            util_1.log("Removing %s", installerOut);
            yield bluebird_1.Promise.all([this.packApp(this.computePackOptions(outDir, arch), appOutDir), fs_extra_p_1.emptyDir(installerOut)]);
            const extraResources = yield this.copyExtraResources(appOutDir, arch);
            if (extraResources.length > 0) {
                this.extraNuGetFileSources = bluebird_1.Promise.map(extraResources, file => {
                    return fs_extra_p_1.stat(file).then(it => {
                        const relativePath = path.relative(appOutDir, file);
                        const src = it.isDirectory() ? `${ relativePath }${ path.sep }**` : relativePath;
                        return `<file src="${ src }" target="lib\\net45\\${ relativePath.replace(/\//g, "\\") }"/>`;
                    });
                });
            }
            if (this.options.dist) {
                postAsyncTasks.push(this.packageInDistributableFormat(outDir, appOutDir, arch));
            }
        });
    }
    packApp(options, appOutDir) {
        const _super = name => super[name];
        return __awaiter(this, void 0, void 0, function* () {
            yield _super("packApp").call(this, options, appOutDir);
            if (process.platform === "darwin" && this.options.cscLink != null && this.options.cscKeyPassword != null) {
                const filename = this.appName + ".exe";
                util_1.log(`Signing ${ filename }`);
                yield bluebird_1.Promise.promisify(signcode_tf_1.sign)({
                    path: path.join(appOutDir, filename),
                    cert: yield this.certFilePromise,
                    password: this.options.cscKeyPassword,
                    name: this.appName,
                    site: yield this.computePackageUrl(),
                    hash: ["sha256"],
                    overwrite: true
                });
            }
        });
    }
    computeEffectiveDistOptions(appOutDir, installerOutDir) {
        return __awaiter(this, void 0, void 0, function* () {
            let iconUrl = this.devMetadata.build.iconUrl;
            if (!iconUrl) {
                util_1.use(this.customBuildOptions, it => iconUrl = it.iconUrl);
                if (!iconUrl && this.info.repositoryInfo != null) {
                    const info = yield this.info.repositoryInfo.getInfo(this);
                    if (info != null) {
                        iconUrl = `https://raw.githubusercontent.com/${ info.user }/${ info.project }/master/${ this.relativeBuildResourcesDirname }/icon.ico`;
                    }
                }
                if (!iconUrl) {
                    throw new Error("iconUrl is not specified, please see https://github.com/electron-userland/electron-builder#in-short");
                }
            }
            util_1.use(this.customBuildOptions, checkConflictingOptions);
            const projectUrl = yield this.computePackageUrl();
            const options = Object.assign({
                name: this.metadata.name,
                productName: this.appName,
                exe: this.appName + ".exe",
                title: this.appName,
                appDirectory: appOutDir,
                outputDirectory: installerOutDir,
                version: this.metadata.version,
                description: this.metadata.description,
                authors: this.metadata.author.name,
                iconUrl: iconUrl,
                setupIcon: yield this.iconPath,
                certificateFile: yield this.certFilePromise,
                certificatePassword: this.options.cscKeyPassword,
                fixUpPaths: false,
                skipUpdateIcon: true,
                usePackageJson: false,
                noMsi: true,
                extraFileSpecs: this.extraNuGetFileSources == null ? null : "\n" + (yield this.extraNuGetFileSources).join("\n"),
                extraMetadataSpecs: projectUrl == null ? null : `\n<projectUrl>${ projectUrl }</projectUrl>`,
                sign: {
                    name: this.appName,
                    site: projectUrl,
                    hash: ["sha256"],
                    overwrite: true
                }
            }, this.customBuildOptions);
            if (this.loadingGifStat != null) {
                options.loadingGif = yield this.loadingGifStat;
            }
            return options;
        });
    }
    packageInDistributableFormat(outDir, appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            const installerOutDir = computeDistOut(outDir, arch);
            yield require("electron-winstaller-fixed").createWindowsInstaller((yield this.computeEffectiveDistOptions(appOutDir, installerOutDir)));
            const version = this.metadata.version;
            const archSuffix = arch === "x64" ? "" : "-" + arch;
            const releasesFile = path.join(installerOutDir, "RELEASES");
            const nupkgPathOriginal = this.metadata.name + "-" + version + "-full.nupkg";
            const nupkgPathWithArch = this.metadata.name + "-" + version + archSuffix + "-full.nupkg";
            function changeFileNameInTheReleasesFile() {
                return __awaiter(this, void 0, void 0, function* () {
                    const data = (yield fs_extra_p_1.readFile(releasesFile, "utf8")).replace(new RegExp(" " + nupkgPathOriginal + " ", "g"), " " + nupkgPathWithArch + " ");
                    yield fs_extra_p_1.writeFile(releasesFile, data);
                });
            }
            const promises = [fs_extra_p_1.rename(path.join(installerOutDir, "Setup.exe"), path.join(installerOutDir, `${ this.appName }Setup-${ version }${ archSuffix }.exe`)).then(it => this.dispatchArtifactCreated(it, `${ this.metadata.name }Setup-${ version }${ archSuffix }.exe`))];
            if (archSuffix === "") {
                this.dispatchArtifactCreated(path.join(installerOutDir, nupkgPathOriginal));
                this.dispatchArtifactCreated(path.join(installerOutDir, "RELEASES"));
            } else {
                promises.push(fs_extra_p_1.rename(path.join(installerOutDir, nupkgPathOriginal), path.join(installerOutDir, nupkgPathWithArch)).then(it => this.dispatchArtifactCreated(it)));
                promises.push(changeFileNameInTheReleasesFile().then(() => fs_extra_p_1.copy(releasesFile, path.join(installerOutDir, "RELEASES-ia32"))).then(it => this.dispatchArtifactCreated(it)));
            }
            yield bluebird_1.Promise.all(promises);
        });
    }
}
exports.WinPackager = WinPackager;
function checkIcon(file) {
    return __awaiter(this, void 0, void 0, function* () {
        const fd = yield fs_extra_p_1.open(file, "r");
        const buffer = new Buffer(512);
        try {
            yield fs_extra_p_1.read(fd, buffer, 0, buffer.length, 0);
        } finally {
            yield fs_extra_p_1.close(fd);
        }
        const sizes = parseIco(buffer);
        for (let size of sizes) {
            if (size.w >= 256 && size.h >= 256) {
                return;
            }
        }
        throw new Error("Windows icon image size must be at least 256x256");
    });
}
function parseIco(buffer) {
    if (!isIco(buffer)) {
        throw new Error("buffer is not ico");
    }
    const n = buffer.readUInt16LE(4);
    const result = new Array(n);
    for (let i = 0; i < n; i++) {
        result[i] = {
            w: buffer.readUInt8(6 + i * 16) || 256,
            h: buffer.readUInt8(7 + i * 16) || 256
        };
    }
    return result;
}
function isIco(buffer) {
    return buffer.readUInt16LE(0) === 0 && buffer.readUInt16LE(2) === 1;
}
function computeDistOut(outDir, arch) {
    return path.join(outDir, "win" + (arch === "x64" ? "-x64" : ""));
}
exports.computeDistOut = computeDistOut;
function checkConflictingOptions(options) {
    for (let name of ["outputDirectory", "appDirectory", "exe", "fixUpPaths", "usePackageJson", "extraFileSpecs", "extraMetadataSpecs", "skipUpdateIcon", "setupExe"]) {
        if (name in options) {
            throw new Error(`Option ${ name } is ignored, do not specify it.`);
        }
    }
    const noMsi = options.noMsi;
    if (noMsi != null && typeof noMsi !== "boolean") {
        throw new Error(`noMsi expected to be boolean value, but string '"${ noMsi }"' was specified`);
    }
}
//# sourceMappingURL=winPackager.js.map