"use strict";

const platformPackager_1 = require("./platformPackager");
const metadata_1 = require("./metadata");
const path = require("path");
const bluebird_1 = require("bluebird");
const util_1 = require("./util");
const codeSign_1 = require("./codeSign");
const _7zip_bin_1 = require("7zip-bin");
const deepAssign = require("deep-assign");
const electron_osx_sign_tf_1 = require("electron-osx-sign-tf");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./awaiter");
class OsXPackager extends platformPackager_1.PlatformPackager {
    constructor(info, cleanupTasks) {
        super(info);
        if (this.options.cscLink != null && this.options.cscKeyPassword != null) {
            const keychainName = codeSign_1.generateKeychainName();
            cleanupTasks.push(() => codeSign_1.deleteKeychain(keychainName));
            this.codeSigningInfo = codeSign_1.createKeychain(keychainName, this.options.cscLink, this.options.cscKeyPassword, this.options.cscInstallerLink, this.options.cscInstallerKeyPassword, this.options.csaLink);
        } else {
            this.codeSigningInfo = bluebird_1.Promise.resolve(null);
        }
        const targets = platformPackager_1.normalizeTargets(this.customBuildOptions == null ? null : this.customBuildOptions.target);
        if (targets != null) {
            for (let target of targets) {
                if (target !== "default" && target !== "dmg" && target !== "zip" && target !== "mas" && target !== "7z") {
                    throw new Error("Unknown target: " + target);
                }
            }
        }
        this.targets = targets == null ? ["default"] : targets;
    }
    get platform() {
        return metadata_1.Platform.OSX;
    }
    pack(outDir, arch, postAsyncTasks) {
        return __awaiter(this, void 0, void 0, function* () {
            const packOptions = this.computePackOptions(outDir, arch);
            let nonMasPromise = null;
            if (this.targets.length > 1 || this.targets[0] !== "mas") {
                const appOutDir = this.computeAppOutDir(outDir, arch);
                nonMasPromise = this.doPack(packOptions, outDir, appOutDir, arch).then(() => this.sign(appOutDir, false)).then(() => postAsyncTasks.push(this.packageInDistributableFormat(outDir, appOutDir, arch)));
            }
            if (this.targets.indexOf("mas") !== -1) {
                // osx-sign - disable warning
                const appOutDir = path.join(outDir, `${ this.appName }-mas-${ arch }`);
                yield this.doPack(Object.assign({}, packOptions, { platform: "mas", "osx-sign": false }), outDir, appOutDir, arch);
                yield this.sign(appOutDir, true);
            }
            if (nonMasPromise != null) {
                yield nonMasPromise;
            }
        });
    }
    sign(appOutDir, isMas) {
        return __awaiter(this, void 0, void 0, function* () {
            let codeSigningInfo = yield this.codeSigningInfo;
            if (codeSigningInfo == null) {
                codeSigningInfo = {
                    name: this.options.sign || process.env.CSC_NAME,
                    installerName: this.options.sign || process.env.CSC_INSTALLER_NAME
                };
            }
            if (codeSigningInfo.name == null) {
                util_1.log("App is not signed: CSC_LINK or CSC_NAME are not specified");
                return;
            }
            util_1.log("Signing app");
            const baseSignOptions = {
                app: path.join(appOutDir, this.appName + ".app"),
                platform: isMas ? "mas" : "darwin"
            };
            if (codeSigningInfo.keychainName != null) {
                baseSignOptions.keychain = codeSigningInfo.keychainName;
            }
            yield bluebird_1.Promise.promisify(electron_osx_sign_tf_1.sign)(Object.assign({
                identity: codeSigningInfo.name
            }, this.devMetadata.build["osx-sign"], baseSignOptions));
            if (isMas) {
                const installerIdentity = codeSigningInfo.installerName;
                if (installerIdentity == null) {
                    throw new Error("Signing is required for mas builds but CSC_INSTALLER_LINK or CSC_INSTALLER_NAME are not specified");
                }
                const pkg = path.join(appOutDir, `${ this.appName }-${ this.metadata.version }.pkg`);
                yield bluebird_1.Promise.promisify(electron_osx_sign_tf_1.flat)(Object.assign({
                    pkg: pkg,
                    identity: installerIdentity
                }, baseSignOptions));
                this.dispatchArtifactCreated(pkg, `${ this.metadata.name }-${ this.metadata.version }.pkg`);
            }
        });
    }
    computeEffectiveDistOptions(appOutDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const specification = deepAssign({
                title: this.appName,
                icon: path.join(this.buildResourcesDir, "icon.icns"),
                "icon-size": 80,
                contents: [{
                    "x": 410, "y": 220, "type": "link", "path": "/Applications"
                }, {
                    "x": 130, "y": 220, "type": "file"
                }]
            }, this.customBuildOptions);
            if (this.customBuildOptions == null || !("background" in this.customBuildOptions)) {
                const background = path.join(this.buildResourcesDir, "background.png");
                const info = yield util_1.statOrNull(background);
                if (info != null && info.isFile()) {
                    specification.background = background;
                }
            }
            specification.contents[1].path = path.join(appOutDir, this.appName + ".app");
            return specification;
        });
    }
    packageInDistributableFormat(outDir, appOutDir, arch) {
        const promises = [];
        if (this.targets.indexOf("dmg") !== -1 || this.targets.indexOf("default") !== -1) {
            const artifactPath = path.join(appOutDir, `${ this.appName }-${ this.metadata.version }.dmg`);
            promises.push(new bluebird_1.Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                util_1.log("Creating DMG");
                const dmgOptions = {
                    target: artifactPath,
                    basepath: this.projectDir,
                    specification: yield this.computeEffectiveDistOptions(appOutDir),
                    compression: this.devMetadata.build.compression === "store" ? "NONE" : "UDBZ"
                };
                if (util_1.debug.enabled) {
                    util_1.debug(`appdmg: ${ JSON.stringify(dmgOptions, null, 2) }`);
                }
                const emitter = require("appdmg-tf")(dmgOptions);
                emitter.on("error", reject);
                emitter.on("finish", () => resolve());
                if (util_1.debug.enabled) {
                    emitter.on("progress", info => {
                        if (info.type === "step-begin") {
                            util_1.debug(`appdmg: [${ info.current }] ${ info.title }`);
                        }
                    });
                }
            })).then(() => this.dispatchArtifactCreated(artifactPath, `${ this.metadata.name }-${ this.metadata.version }.dmg`)));
        }
        for (let target of this.targets) {
            if (target !== "mas" && target !== "dmg") {
                const format = target === "default" ? "zip" : target;
                util_1.log("Creating OS X " + format);
                // for default we use mac to be compatible with Squirrel.Mac
                const classifier = target === "default" ? "mac" : "osx";
                promises.push(this.archiveApp(appOutDir, format, classifier).then(it => this.dispatchArtifactCreated(it, `${ this.metadata.name }-${ this.metadata.version }-${ classifier }.${ format }`)));
            }
        }
        return bluebird_1.Promise.all(promises);
    }
    archiveApp(outDir, format, classifier) {
        const args = ["a", "-bb" + (util_1.debug.enabled ? "3" : "0"), "-bd"];
        const compression = this.devMetadata.build.compression;
        const storeOnly = compression === "store";
        if (format === "zip" || storeOnly) {
            args.push("-mm=" + (storeOnly ? "Copy" : "Deflate"));
        }
        if (compression === "maximum") {
            // http://superuser.com/a/742034
            //noinspection SpellCheckingInspection
            args.push("-mfb=258", "-mpass=15");
        }
        // we use app name here - see https://github.com/electron-userland/electron-builder/pull/204
        const resultPath = `${ this.appName }-${ this.metadata.version }-${ classifier }.${ format }`;
        args.push(resultPath, this.appName + ".app");
        return util_1.spawn(_7zip_bin_1.path7za, args, {
            cwd: outDir,
            stdio: ["ignore", util_1.debug.enabled ? "inherit" : "ignore", "inherit"]
        }).thenReturn(path.join(outDir, resultPath));
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = OsXPackager;
//# sourceMappingURL=osxPackager.js.map