"use strict";

const metadata_1 = require("./metadata");
const bluebird_1 = require("bluebird");
const path = require("path");
const packager = require("electron-packager-tf");
const globby = require("globby");
const fs_extra_p_1 = require("fs-extra-p");
const util_1 = require("./util");
const deepAssign = require("deep-assign");
const asar_1 = require("asar");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("./awaiter");
const pack = bluebird_1.Promise.promisify(packager);
class PlatformPackager {
    constructor(info) {
        this.info = info;
        this.options = info.options;
        this.projectDir = info.projectDir;
        this.metadata = info.metadata;
        this.devMetadata = info.devMetadata;
        this.buildResourcesDir = path.resolve(this.projectDir, this.relativeBuildResourcesDirname);
        this.customBuildOptions = info.devMetadata.build[this.platform.buildConfigurationKey];
        this.appName = metadata_1.getProductName(this.metadata, this.devMetadata);
    }
    get platform() {}
    get relativeBuildResourcesDirname() {
        return util_1.use(this.devMetadata.directories, it => it.buildResources) || "build";
    }
    computeAppOutDir(outDir, arch) {
        return path.join(outDir, `${ this.appName }-${ this.platform.nodeName }-${ arch }`);
    }
    dispatchArtifactCreated(file, artifactName) {
        this.info.eventEmitter.emit("artifactCreated", {
            file: file,
            artifactName: artifactName,
            platform: this.platform
        });
    }
    pack(outDir, arch, postAsyncTasks) {
        const appOutDir = this.computeAppOutDir(outDir, arch);
        return this.doPack(this.computePackOptions(outDir, arch), outDir, appOutDir, arch, postAsyncTasks);
    }
    doPack(options, outDir, appOutDir, arch) {
        let postAsyncTasks = arguments.length <= 4 || arguments[4] === undefined ? null : arguments[4];

        return __awaiter(this, void 0, void 0, function* () {
            yield this.packApp(options, appOutDir);
            yield this.copyExtraResources(appOutDir, arch);
            if (postAsyncTasks != null && this.options.dist) {
                postAsyncTasks.push(this.packageInDistributableFormat(outDir, appOutDir, arch));
            }
        });
    }
    computePackOptions(outDir, arch) {
        const version = this.metadata.version;
        let buildVersion = version;
        const buildNumber = this.computeBuildNumber();
        if (buildNumber != null) {
            buildVersion += "." + buildNumber;
        }
        const options = deepAssign({
            dir: this.info.appDir,
            out: outDir,
            name: this.appName,
            platform: this.platform.nodeName,
            arch: arch,
            version: this.info.electronVersion,
            icon: path.join(this.buildResourcesDir, "icon"),
            asar: true,
            overwrite: true,
            "app-version": version,
            "build-version": buildVersion,
            tmpdir: false,
            "version-string": {
                CompanyName: this.metadata.author.name,
                FileDescription: this.metadata.description,
                ProductName: this.appName,
                InternalName: this.appName
            }
        }, this.devMetadata.build);
        delete options.osx;
        delete options.win;
        delete options.linux;
        // this option only for windows-installer
        delete options.iconUrl;
        return options;
    }
    packApp(options, appOutDir) {
        return __awaiter(this, void 0, void 0, function* () {
            yield pack(options);
            yield this.sanityCheckPackage(appOutDir, options.asar);
        });
    }
    getExtraResources(arch) {
        const buildMetadata = this.devMetadata.build;
        let extraResources = buildMetadata == null ? null : buildMetadata.extraResources;
        const platformSpecificExtraResources = this.customBuildOptions == null ? null : this.customBuildOptions.extraResources;
        if (platformSpecificExtraResources != null) {
            extraResources = extraResources == null ? platformSpecificExtraResources : extraResources.concat(platformSpecificExtraResources);
        }
        if (extraResources == null) {
            return bluebird_1.Promise.resolve([]);
        }
        const expandedPatterns = extraResources.map(it => it.replace(/\$\{arch}/g, arch).replace(/\$\{os}/g, this.platform.buildConfigurationKey));
        return globby(expandedPatterns, { cwd: this.projectDir });
    }
    copyExtraResources(appOutDir, arch) {
        return __awaiter(this, void 0, void 0, function* () {
            let resourcesDir = appOutDir;
            if (this.platform === metadata_1.Platform.OSX) {
                resourcesDir = this.getOSXResourcesDir(appOutDir);
            }
            return yield bluebird_1.Promise.map((yield this.getExtraResources(arch)), it => fs_extra_p_1.copy(path.join(this.projectDir, it), path.join(resourcesDir, it)));
        });
    }
    computePackageUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = this.metadata.homepage || this.devMetadata.homepage;
            if (url != null) {
                return url;
            }
            if (this.info.repositoryInfo != null) {
                const info = yield this.info.repositoryInfo.getInfo(this);
                if (info != null) {
                    return `https://github.com/${ info.user }/${ info.project }`;
                }
            }
            return null;
        });
    }
    computeBuildNumber() {
        return this.devMetadata.build["build-version"] || process.env.TRAVIS_BUILD_NUMBER || process.env.APPVEYOR_BUILD_NUMBER || process.env.CIRCLE_BUILD_NUM;
    }
    getOSXResourcesDir(appOutDir) {
        return path.join(appOutDir, this.appName + ".app", "Contents", "Resources");
    }
    statFileInPackage(appOutDir, packageFile, isAsar) {
        return __awaiter(this, void 0, void 0, function* () {
            const relativeFile = path.relative(this.info.appDir, path.resolve(this.info.appDir, packageFile));
            const resourcesDir = this.platform === metadata_1.Platform.OSX ? this.getOSXResourcesDir(appOutDir) : path.join(appOutDir, "resources");
            if (isAsar) {
                try {
                    const fsAsar = asar_1.statFile(path.join(resourcesDir, "app.asar"), relativeFile);
                    return fsAsar != null;
                } catch (e) {
                    // asar throws error on access to undefined object (info.link)
                    return false;
                }
            } else {
                const outStat = yield util_1.statOrNull(path.join(resourcesDir, "app", relativeFile));
                return outStat != null && outStat.isFile();
            }
        });
    }
    sanityCheckPackage(appOutDir, asar) {
        return __awaiter(this, void 0, void 0, function* () {
            const outStat = yield util_1.statOrNull(appOutDir);
            if (outStat == null) {
                throw new Error(`Output directory ${ appOutDir } does not exists. Seems like a wrong configuration.`);
            } else if (!outStat.isDirectory()) {
                throw new Error(`Output directory ${ appOutDir } is not a directory. Seems like a wrong configuration.`);
            }
            const mainFile = this.metadata.main || "index.js";
            const mainFileExists = yield this.statFileInPackage(appOutDir, mainFile, asar);
            if (!mainFileExists) {
                throw new Error(`Application entry file ${ mainFile } could not be found in package. Seems like a wrong configuration.`);
            }
        });
    }
}
exports.PlatformPackager = PlatformPackager;
function normalizeTargets(targets) {
    if (targets == null) {
        return null;
    } else {
        return (Array.isArray(targets) ? targets : [targets]).map(it => it.toLowerCase().trim());
    }
}
exports.normalizeTargets = normalizeTargets;
//# sourceMappingURL=platformPackager.js.map