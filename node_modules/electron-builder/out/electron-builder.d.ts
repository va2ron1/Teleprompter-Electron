declare module 'electron-builder/out/awaiter' {
   var _default: (thisArg: any, _arguments: any, ignored: any, generator: Function) => any
  export = _default
}

declare module 'electron-builder/out/builder' {
  import { Packager } from "electron-builder/out/packager"
  import { PackagerOptions } from "electron-builder/out/platformPackager"
  import { PublishOptions, Publisher } from "electron-builder/out/gitHubPublisher"
  import { InfoRetriever } from "electron-builder/out/repositoryInfo"

  export function createPublisher(packager: Packager, options: BuildOptions, repoSlug: InfoRetriever, isPublishOptionGuessed?: boolean): Promise<Publisher>

  export interface BuildOptions extends PackagerOptions, PublishOptions {
  }

  export function build(originalOptions?: BuildOptions): Promise<void>
}

declare module 'electron-builder/out/codeSign' {
  import { Promise as BluebirdPromise } from "bluebird"

  export interface CodeSigningInfo {
    name: string
    keychainName?: string
    installerName?: string
  }

  export function generateKeychainName(): string

  export function createKeychain(keychainName: string, cscLink: string, cscKeyPassword: string, cscILink?: string, cscIKeyPassword?: string, csaLink?: string): Promise<CodeSigningInfo>

  export function sign(path: string, options: CodeSigningInfo): BluebirdPromise<any>

  export function deleteKeychain(keychainName: string, ignoreNotFound?: boolean): BluebirdPromise<any>

  export function downloadCertificate(cscLink: string): Promise<string>
}

declare module 'electron-builder/out/errorMessages' {
  export const buildIsMissed: string
  export const authorEmailIsMissed: string
  export const buildInAppSpecified: string
}

declare module 'electron-builder/out/gitHubPublisher' {
  import { Release } from "gh-release"

  export interface Publisher {
    upload(file: string, artifactName?: string): Promise<any>
  }

  export interface PublishOptions {
    publish?: "onTag" | "onTagOrDraft" | "always" | "never"
    githubToken?: string
  }

  export class GitHubPublisher implements Publisher {
    readonly releasePromise: Promise<Release>
    constructor(owner: string, repo: string, version: string, token: string, createReleaseIfNotExists?: boolean)
    upload(file: string, artifactName?: string): Promise<void>
    deleteRelease(): Promise<void>
  }
}

declare module 'electron-builder/out/gitHubRequest' {
  import { RequestOptions } from "https"
  import { IncomingMessage, ClientRequest } from "http"
  import { Promise as BluebirdPromise } from "bluebird"

  export function gitHubRequest<T>(path: string, token: string, data?: {
    [name: string]: any
  }, method?: string): BluebirdPromise<T>

  export function doGitHubRequest<T>(options: RequestOptions, token: string, requestProcessor: (request: ClientRequest, reject: (error: Error) => void) => void): BluebirdPromise<T>

  export class HttpError extends Error {
    response: IncomingMessage
    description: any
    constructor(response: IncomingMessage, description?: any)
  }
}

declare module 'electron-builder/out/httpRequest' {
  import { ClientRequest } from "http"
  import { Promise as BluebirdPromise } from "bluebird"
  export const download: (arg1: string, arg2: string) => BluebirdPromise<{}>

  export function addTimeOutHandler(request: ClientRequest, callback: (error: Error | string) => void): void
}

declare module 'electron-builder' {
  export { Packager } from "electron-builder/out/packager"
  export { PackagerOptions, ArtifactCreated } from "electron-builder/out/platformPackager"
  export { BuildOptions, build, createPublisher } from "electron-builder/out/builder"
  export { PublishOptions, Publisher } from "electron-builder/out/gitHubPublisher"
  export { AppMetadata, DevMetadata, Platform, getProductName, BuildMetadata, OsXBuildOptions, WinBuildOptions, LinuxBuildOptions } from "electron-builder/out/metadata"
}

declare module 'electron-builder/out/linuxPackager' {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform, LinuxBuildOptions } from "electron-builder/out/metadata"

  export class LinuxPackager extends PlatformPackager<LinuxBuildOptions> {
    constructor(info: BuildInfo)
    readonly platform: Platform
    packageInDistributableFormat(outDir: string, appOutDir: string, arch: string): Promise<any>
  }
}

declare module 'electron-builder/out/metadata' {
  
  export interface Metadata {
    readonly repository?: string | RepositoryInfo
  }

  export interface AppMetadata extends Metadata {
    readonly version: string
    readonly name: string
    readonly productName?: string
    readonly description: string
    readonly main?: string
    readonly author: AuthorMetadata
    readonly homepage?: string
    readonly license?: string
  }

  export interface DevMetadata extends Metadata {
    readonly build: BuildMetadata
    readonly homepage?: string
    readonly license?: string
    readonly directories?: MetadataDirectories
  }

  export interface RepositoryInfo {
    readonly url: string
  }

  export interface AuthorMetadata {
    readonly name: string
    readonly email: string
  }

  export interface BuildMetadata {
    readonly "app-bundle-id"?: string
    readonly "app-category-type"?: string
    readonly asar?: boolean
    readonly iconUrl?: string
    readonly productName?: string
    /**
     A [glob expression](https://www.npmjs.com/package/glob#glob-primer), when specified, copy the file or directory with matching names directly into the app's directory (`Contents/Resources` for OS X).
  
     You can use `${os}` (expanded to osx, linux or win according to current platform) and `${arch}` in the pattern.
  
     If directory matched, all contents are copied. So, you can just specify `foo` to copy `<project_dir>/foo` directory.
  
     May be specified in the platform options (i.e. in the `build.osx`).
     */
    readonly extraResources?: Array<string>
    readonly osx?: OsXBuildOptions
    /**
     See [.build.win](#LinuxBuildOptions).
     */
    readonly win?: any
    readonly linux?: LinuxBuildOptions
    readonly compression?: "store" | "normal" | "maximum"
    readonly "build-version"?: string
  }

  export interface OsXBuildOptions extends PlatformSpecificBuildOptions {
    readonly icon?: string
    readonly background?: string
    readonly target?: Array<string>
  }

  export interface WinBuildOptions extends PlatformSpecificBuildOptions {
    readonly certificateFile?: string
    readonly certificatePassword?: string
    readonly iconUrl?: string
    readonly loadingGif?: string
    /**
     Whether to create an MSI installer. Defaults to `true` (MSI is not created).
     */
    readonly noMsi?: boolean
  }

  export interface LinuxBuildOptions {
    description?: string
    synopsis?: string
    maintainer?: string
    vendor?: string
    fpm?: string[]
    desktop?: string
    afterInstall?: string
    afterRemove?: string
    readonly compression?: string
  }

  export interface MetadataDirectories {
    readonly buildResources?: string
    readonly output?: string
    readonly app?: string
  }

  export interface PlatformSpecificBuildOptions {
    readonly extraResources?: Array<string>
  }

  export class Platform {
    name: string
    buildConfigurationKey: string
    nodeName: string
    static OSX: Platform
    static LINUX: Platform
    static WINDOWS: Platform
    constructor(name: string, buildConfigurationKey: string, nodeName: string)
    toString(): string
    static fromString(name: string): Platform
  }

  export function getProductName(metadata: AppMetadata, devMetadata: DevMetadata): string
}

declare module 'electron-builder/out/osxPackager' {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform, OsXBuildOptions } from "electron-builder/out/metadata"
  import { CodeSigningInfo } from "electron-builder/out/codeSign"

  export default class OsXPackager extends PlatformPackager<OsXBuildOptions> {
    codeSigningInfo: Promise<CodeSigningInfo>
    readonly targets: Array<string>
    constructor(info: BuildInfo, cleanupTasks: Array<() => Promise<any>>)
    readonly platform: Platform
    pack(outDir: string, arch: string, postAsyncTasks: Array<Promise<any>>): Promise<any>
    protected computeEffectiveDistOptions(appOutDir: string): Promise<appdmg.Specification>
    packageInDistributableFormat(outDir: string, appOutDir: string, arch: string): Promise<any>
  }
}

declare module 'electron-builder/out/packager' {
  import { EventEmitter } from "events"
  import { InfoRetriever } from "electron-builder/out/repositoryInfo"
  import { AppMetadata, DevMetadata, Platform } from "electron-builder/out/metadata"
  import { PackagerOptions, BuildInfo, ArtifactCreated } from "electron-builder/out/platformPackager"

  export class Packager implements BuildInfo {
    options: PackagerOptions
    repositoryInfo: InfoRetriever
    readonly projectDir: string
    appDir: string
    metadata: AppMetadata
    devMetadata: DevMetadata
    electronVersion: string
    readonly eventEmitter: EventEmitter
    constructor(options: PackagerOptions, repositoryInfo?: InfoRetriever)
    artifactCreated(handler: (event: ArtifactCreated) => void): Packager
    readonly devPackageFile: string
    build(): Promise<any>
  }

  export function normalizeArchs(platform: Platform, arch?: string): string[]

  export function normalizePlatforms(platforms: Array<string | Platform>): Array<Platform>
}

declare module 'electron-builder/out/platformPackager' {
  import { InfoRetriever, ProjectMetadataProvider } from "electron-builder/out/repositoryInfo"
  import { AppMetadata, DevMetadata, Platform, PlatformSpecificBuildOptions } from "electron-builder/out/metadata"
  import EventEmitter = NodeJS.EventEmitter
  import { Packager } from "electron-builder/out/packager"
  import ElectronPackagerOptions = ElectronPackager.ElectronPackagerOptions

  export interface PackagerOptions {
    arch?: string
    dist?: boolean
    githubToken?: string
    sign?: string
    platform?: Array<Platform>
    appDir?: string
    projectDir?: string
    cscLink?: string
    csaLink?: string
    cscKeyPassword?: string
    cscInstallerLink?: string
    cscInstallerKeyPassword?: string
    platformPackagerFactory?: (packager: Packager, platform: Platform, cleanupTasks: Array<() => Promise<any>>) => PlatformPackager<any>
    /**
     * The same as [development package.json](https://github.com/electron-userland/electron-builder/wiki/Options#development-packagejson).
     *
     * Development `package.json` will be still read, but options specified in this object will override.
     */
    readonly devMetadata?: DevMetadata
  }

  export interface BuildInfo extends ProjectMetadataProvider {
    options: PackagerOptions
    devMetadata: DevMetadata
    projectDir: string
    appDir: string
    electronVersion: string
    repositoryInfo: InfoRetriever
    eventEmitter: EventEmitter
  }

  export abstract class PlatformPackager<DC extends PlatformSpecificBuildOptions> implements ProjectMetadataProvider {
    protected info: BuildInfo
    protected readonly options: PackagerOptions
    protected readonly projectDir: string
    protected readonly buildResourcesDir: string
    readonly metadata: AppMetadata
    readonly devMetadata: DevMetadata
    customBuildOptions: DC
    readonly appName: string
    readonly abstract platform: Platform
    constructor(info: BuildInfo)
    protected readonly relativeBuildResourcesDirname: string
    protected computeAppOutDir(outDir: string, arch: string): string
    protected dispatchArtifactCreated(file: string, artifactName?: string): void
    pack(outDir: string, arch: string, postAsyncTasks: Array<Promise<any>>): Promise<any>
    protected doPack(options: ElectronPackagerOptions, outDir: string, appOutDir: string, arch: string, postAsyncTasks?: Array<Promise<any>>): Promise<void>
    protected computePackOptions(outDir: string, arch: string): ElectronPackagerOptions
    protected packApp(options: ElectronPackagerOptions, appOutDir: string): Promise<any>
    protected getExtraResources(arch: string): Promise<Array<string>>
    protected copyExtraResources(appOutDir: string, arch: string): Promise<Array<string>>
    protected abstract packageInDistributableFormat(outDir: string, appOutDir: string, arch: string): Promise<any>
    protected computePackageUrl(): Promise<string>
    protected computeBuildNumber(): string
  }

  export interface ArtifactCreated {
    readonly file: string
    readonly artifactName?: string
    readonly platform: Platform
  }

  export function normalizeTargets(targets: Array<string> | string): Array<string>
}

declare module 'electron-builder/out/promise' {
  import { Promise as BluebirdPromise } from "bluebird"

  export function printErrorAndExit(error: Error): void

  export function executeFinally(promise: Promise<any>, task: (errorOccurred: boolean) => Promise<any>): Promise<any>

  export class NestedError extends Error {
    constructor(errors: Array<Error>, message?: string)
  }

  export function all(promises: Array<Promise<any>>): BluebirdPromise<any>
}

declare module 'electron-builder/out/repositoryInfo' {
  import { Info } from "hosted-git-info"
  import { AppMetadata, Metadata } from "electron-builder/out/metadata"

  export interface ProjectMetadataProvider {
    metadata: AppMetadata
    devMetadata: Metadata
  }

  export interface RepositorySlug {
    user: string
    project: string
  }

  export class InfoRetriever {
    _info: Promise<Info>
    getInfo(provider?: ProjectMetadataProvider): Promise<Info>
  }
}

declare module 'electron-builder/out/util' {
  import { Promise as BluebirdPromise } from "bluebird"
  import { Debugger } from "~debug/node"
  export const log: (message?: any, ...optionalParams: any[]) => void
  export const debug: Debugger

  export function warn(message: string): void
  export const readPackageJson: (arg1: string) => BluebirdPromise<any>

  export function installDependencies(appDir: string, electronVersion: string, arch?: string, command?: string): BluebirdPromise<any>

  export interface BaseExecOptions {
    cwd?: string
    env?: any
    stdio?: any
  }

  export interface ExecOptions extends BaseExecOptions {
    customFds?: any
    encoding?: string
    timeout?: number
    maxBuffer?: number
    killSignal?: string
  }

  export interface SpawnOptions extends BaseExecOptions {
    custom?: any
    detached?: boolean
  }

  export function exec(file: string, args?: string[], options?: ExecOptions): BluebirdPromise<Buffer[]>

  export function spawn(command: string, args?: string[], options?: SpawnOptions): BluebirdPromise<any>

  export function getElectronVersion(packageData: any, packageJsonPath: string): Promise<string>

  export function statOrNull(file: string): Promise<any>

  export function computeDefaultAppDirectory(projectDir: string, userAppDir: string): Promise<string>

  export function use<T, R>(value: T, task: (it: T) => R): R
}

declare module 'electron-builder/out/winPackager' {
  import { PlatformPackager, BuildInfo } from "electron-builder/out/platformPackager"
  import { Platform, WinBuildOptions } from "electron-builder/out/metadata"

  export class WinPackager extends PlatformPackager<WinBuildOptions> {
    certFilePromise: Promise<string>
    extraNuGetFileSources: Promise<Array<string>>
    loadingGifStat: Promise<string>
    readonly iconPath: Promise<string>
    constructor(info: BuildInfo, cleanupTasks: Array<() => Promise<any>>)
    readonly platform: Platform
    pack(outDir: string, arch: string, postAsyncTasks: Array<Promise<any>>): Promise<any>
    protected packApp(options: any, appOutDir: string): Promise<void>
    protected computeEffectiveDistOptions(appOutDir: string, installerOutDir: string): Promise<any>
    packageInDistributableFormat(outDir: string, appOutDir: string, arch: string): Promise<any>
  }

  export function computeDistOut(outDir: string, arch: string): string
}

